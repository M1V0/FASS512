[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome\nWelcome to FASS512, Quantitative Research Methods for 2023/2024. In the sidebar you will see each week’s worksheets. This is a one-stop shop for all your worksheets, and each week the previous content will have answers incorporated into the content for easier revision.\nSee Moodle for course slides and recordings.\n\n\nHelpful links:\n\nInstalling R and RStudio\nThe Tidyverse Style guide\nHow to search for help on the internet\nAnything you think should be here? Let me know!\n\nContent written by Matthew Ivory, built on Patrick Rebuschat’s previous content; website developed and maintained by Matthew Ivory.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html",
    "href": "Worksheets/Worksheet_wk1.html",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "",
    "text": "This week, we will do our first steps in R. Please work through the following handout at your own pace.\nThree important things to remember:"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-1-using-the-r-console",
    "href": "Worksheets/Worksheet_wk1.html#step-1-using-the-r-console",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 1: Using the R console",
    "text": "Step 1: Using the R console\nR is a command-based system. This means: You type commands (such as the ones highlighted below), R translates the commands into machine instructions, which your computer then executes.\nYou can type the R commands directly into the console. Or, as you will see later, you can also type commands into the script editor and run the sequence of commands as a batch or collection of lines.\nIn the next section, we will try out writing commands in the Console pane.\nCommands are typed at the command prompt &gt;. We then press Return (Mac) / Enter (Windows), and our command is executed. The output of the command, if there is any output, will be displayed on the next line(s)."
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-2-using-r-as-a-calculator",
    "href": "Worksheets/Worksheet_wk1.html#step-2-using-r-as-a-calculator",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 2: Using R as a Calculator",
    "text": "Step 2: Using R as a Calculator\nMost textbooks recommend familiarizing yourself with R and RStudio by first using R as a calculator. Let’s try this out.\nFor example, if you type 10 + 10 in the command prompt and press Return (Mac) / Return (Mac) / Enter (Windows), the result will be displayed underneath:\n\n10 + 10\n\n[1] 20\n\n\nPlease try out the following commands.\nIn the task below, just type the commands in the shaded area, then press Return (Mac) / Enter (Windows).\nNote: You don’t have the leave spaces around the operators (+, -, *, /, etc.), but the lines are more readable if you do.\nSo it’s better if you get used to writing 10 + 10 rather than 10+10, even though the output is the same.\nThe exception are negative values.\nHere, it is recommended not to leave a space between the minus sign - and the value we are negating. So, we would write -3, not - 3, even though it’s the same.\nPlease try out all of the commands on your computer now.\n\nThis is how we do addition\n\n\n10 + 10\n\n\nSubtraction\n\n\n8 - 2\n\n\nMultiplication\n\n\n10 * 14\n\n\nDivision\n\n\n112/8\n\n\nWe can also use exponents, i.e. raising a number to the power of another number, e.g., 2^8, as in the example below\n\n\n2 ^ 8\n\n\nSquare root. This is done via a function called sqrt(). We will discuss functions later. For now, just add a numerical value in the parentheses of sqrt()\n\n\nsqrt(64)\n\n\nYou can also combine +, -, *, /, ^ operators in your commands. By default, the precedence order of operations will be ^ followed by * or /, followed by + or -, just like in a calculator.\n\n\n2+3-4/2\n\nor\n\n3+9/3*2^8\n\n\nBut: You can use brackets () to overcome the default order to operations: Test the effect of bracketing on the precedence order of operations in the two examples below.\n\n\n#example a\n2 + 3 - 4 / 2\n\n#example b\n(2 + 3 - 4) / 2\n\nor\n\n#example a\n3 + 9 / 3 * 2 ^ 8\n\n#Example b\n(3 + 9) / 3 * 2 ^ 8"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-3-history",
    "href": "Worksheets/Worksheet_wk1.html#step-3-history",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 3: History",
    "text": "Step 3: History\nIn the Console pane, have you noticed that pressing the up and down arrows does not allow you to go through the different lines (as would happen in a text file, e.g. Word)? Instead, when you’re at the command prompt &gt;, pressing the up and down arrows allows you to move through the history of executed commands. This can save you a lot of time if you want to re- run one of the previous commands.\nGo ahead and rerun the last line using this method, but change the last number to a 4 (instead of an 8)\nIn the Environment, History, etc. pane, you can use the History tab to see your entire command history. If you click on any line in the History tab, it will re-run the command. Again, very helpful as it saves you a lot of typing. Let’s try this out.\nGo into the History pane and find the line where you ran sqrt(64) and rerun it"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-4-incomplete-commands-and-escaping",
    "href": "Worksheets/Worksheet_wk1.html#step-4-incomplete-commands-and-escaping",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 4: Incomplete commands, and escaping",
    "text": "Step 4: Incomplete commands, and escaping\nWhat happens if you try to execute an incomplete command such as the one below?\n\n\n\n\n10 +\n\nYou will notice there is something missing (another number for the addition). Rather than giving us the result of the addition, R will just display a plus sign + in the console instead of the usual &gt;. This means that the command is incomplete. And: If you keep hitting Return (Mac) / Enter (Windows), you will just get more plus signs…\nYou can either complete the command on the next line (try adding a number to complete the addition), or you can just press Esc to exit the command"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-5-variables",
    "href": "Worksheets/Worksheet_wk1.html#step-5-variables",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 5: Variables",
    "text": "Step 5: Variables\nThe next important step is to learn how to create variables and assign values to variables. In general, the assignment rule is:\nname &lt;- expression/value\nExpression - An expression is any R code that returns some value. This can be a single number, the result of a calculation, or a complex statistical analysis.\nAssignment operator - The &lt;- is called the assignment operator. This assigns everything that is to its right (the expression) to the variable on its left. Rather than typing &lt; and the minus sign, you can also simply press the shortcut Option+- (Mac) or Alt+- (Windows).\nName - The name is simply the name of the variable.\n\nrun the following\n\n\nx &lt;- 4 * 8\n\nIt appears that nothing happened; after all, there seems to be no output in the command prompt. However, something did happen after we executed the command x &lt;- 4 * 8.\nYou will see this when you execute the following command.\n\nx\n\nAs you see, the previous command x &lt;- 4 * 8 assigned the multiplication 4 * 8 to the variable x.\nBy typing the name of the variable x in the command line and running it, the value of the variable will be displayed, in this case 32 (being the product of 4 * 8).\nThere is another way to confirm that you created a variable. If you check the Environment tab in the Environment, History, Connections, etc. pane at the top right of your RStudio window, you will now see that new variable listed.\nOnce you have created a variable, you can use it for other calculations just like you would with any other number\n\n\n\n\nx * 36\n\nWe can also assign any of these values to new variables.\n\n\n\n\ny&lt;-x*28\n\ny"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-6.-naming-your-variables",
    "href": "Worksheets/Worksheet_wk1.html#step-6.-naming-your-variables",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 6. Naming your variables",
    "text": "Step 6. Naming your variables\nThe name has to follow certain naming conventions. The variable name can consist of letters (upper or lower case), numbers, dots, and underscores. However, it must begin with a letter, or a dot that is not followed by a number. That is, a dot not followed by a number, OR a letter. If it is a dot and then number it will think of it as a decimal.\n\nWhich of the following would be okay?\n\n\ny157 &lt;- 2\nx_y_z &lt;- 2\nabc_123 &lt;- 2\n_x &lt;- 2\n.1px &lt;- 2\na_b_c &lt;- 2\nx-y-z &lt;- 2\n123 &lt;- 2\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nthese variable names would work:\n\ny157\nx_y_z\nabc_123\na_b_c\n\nthese will not:\n\n_x starts with an underscore\n.1px starts with a number\nx-y-z is trying to subtract z from y from x (it thinks you want to run a function)\n123 is just a number\n\n\n\n\nEven though you can use nonsense sequences such as the ones above, it is good practice to select variable names that are meaningful, short, without dots (use underscore _ instead), and ideally in lowercase characters. For example:\n\nage &lt;- 56\nincome &lt;- 101034\nis_married &lt;- TRUE\nyears_married &lt;- 27"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-7-data-types",
    "href": "Worksheets/Worksheet_wk1.html#step-7-data-types",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 7: Data Types",
    "text": "Step 7: Data Types\nData types are variables that refer to collections of values. There are different types of data types (e.g., lists, matrices, arrays), but we will focus on two particularly important ones: vectors and data frames.\n\nVectors\nVectors are one-dimensional sequences of values. They are very simple but fundamental data structures, as you will see below when we talk about data frames. For this reason, it’s worth learning about vectors, how to create and manipulate them. Below we will cover numeric and character vectors.\nYou can create vectors by using the c() function. The c stands for combine. All the items within brackets, separated by commas, will be assigned to the variable on the left of the assignment operator.\nIf you type the following command, you will create a vector with seven elements. This is called a numeric vector as the elements within the brackets are numbers.\n\n\n\n\nnumbers &lt;- c(2, 3, 5, 7, 11, 13, 17)\n\nWe can now use this vector to perform all kinds of operations. Try out the following, for example.\n\n\n\n\nnumbers + 1\n\nnumbers / 2\n\nnumbers^2\n\nNote how the operations are applied to each number in the vector.\nFor any vector (number sequence), we can also refer to individual numbers that form the vector. We do this by means of indexing operations []. For example, to get the first element of the vector, we can type the following. This will display the first element in the vector.\n\nnumbers[1]\n\nYou can also extract more than one element from the vector, and even specify the order. For example:\nNote the difference in the example above and the one below. Above, we just used [1] and that was fine, but because of how indexing works (and it gets more complex when handling different datatypes, such as 2-dimensional tables), we need to use the c() function to demonstrate what we are after.\n\nnumbers[c(4,2,1)]\n\nThis will retrieve the fourth element in the vector (the number 7), the first element (2) and the second (3).\n\n\n\n\n\n\nWhy is it different?\n\n\n\n\n\nWhat happens if you don’t use the c() function? Try it out and see what happens.\n\nnumbers[4,2,1]\n\nError in numbers[4, 2, 1]: incorrect number of dimensions\n\n\nYou get an error! Now, in this particular situation, the error message isn’t the most helpful, but it is important to get familiar with errors (you will be seeing a lot of them in the next 10 weeks!), and note that they are useful. R cannot carry out operations that don’t make sense, and as it happens, the above command is telling it to look for the item in three dimensions (imagine a cube made of vectors). When we get errors it is useful to check our code to see what might be wrong.\n\n\n\nOr you can refer to consecutive set of elements in the vector, such as the fourth to the seventh elements. For this, simply type:\n\nnumbers[4:7]\n\nWe can also retrieve all elements with the exception of one. For this, we use the minus sign to exclude the vector element that we want to exclude, as in the following example.\n\nnumbers [-1]\n\nFinally, we can also exclude a sequence of elements by adding the minus sign before the c() function. This will exclude from the output all elements that are specified within the brackets.\n\nnumbers [-c(1, 3, 5, 7)]\n\nThe numbers vector is a sequence of numbers. We can find out the type of vector by using the function class(). This will confirm that numbers is a numeric vector.\n\nclass(numbers)\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nthe class() command is really useful, and one worth remembering for future troubleshooting. Sometimes commands don’t run as you want them to, and checking the class is what you want is a great sanity check. It has saved me on many occasions.\n\n\n\nWe can also create vectors with elements that are character strings. Here, each element needs to be surrounded by quotation marks (single or double), as in the example below\n\ncolleges &lt;- c('bowland', 'cartmel', 'county', 'furness', 'fylde', 'graduate', 'grizedale', 'lonsdale', 'pendle')\n\ncolleges\n\nThis type of vector is character, how would you verify this?\n\n\n\n\n\n\nTip\n\n\n\n\n\n\nclass(colleges)\n\n\n\n\nYou can index character vectors, just like numeric vectors.\n\ncolleges[3]\n\nBut you cannot perform arithmetic functions on character vectors, of course.\n\ncolleges*2\n\n\nCoercing vectors\nIn vectors, all of the elements must be of the same type. For example, you cannot have a vector that has both numbers and character strings as elements. If you try to create a vector with both numbers and character strings, then some of your elements will coerced into other types.\nIf you type the following, you will see that the attempt to create a mixed vector with character strings (bowland, cartmel, county, fylde) and numbers (1, 2, 5, 7, 8) converted the numbers into character strings, as evidenced by the quotation marks. You cannot perform calculations on these numbers as R interprets them as text strings.\n\nc('bowland', 'cartmel', 'county', 'furness', 'fylde', 1, 2, 5, 7, 8)\n\nFinally, you can also combine vectors using thec()function. For example, we can create a new vector called new_numbers by combining the original numbers vectors and adding the squares and cubes of numbers.\n\nnew_numbers &lt;- c(numbers, numbers ^ 2, numbers ^ 3)\n\nnew_numbers\n\nWe have now produced a new vector new_numbers with 21 elements. These don’t fit all in a line and so are wrapped over two lines. The first row displays elements 1 to 12, and the second row begins with element 13. Now you can also see the meaning of the [1] on the output. The [1] is just the index of the first element of the vector show on the corresponding line. [1] refers to the first element in our vector (the number 2), and [13] refers to the 13th element in our vector (169).\n\n\nNaming Vectors\nThe elements of a vector can be named, too. Each element in our vector can have a distinct label, which can be useful.\n\nages &lt;- c(bob = 27, bill = 34, charles = 76)\n\nages\n\nWe can now access the values of the vector by the label or by the index as before.\n\nages['bill']\n\nages[2]\n\nWe can also add names to existing vectors by using the names() function. In the following example, we first assign new values to the vector ages. This will delete the previous numbers and labels. We then assign names to this vector using the names() function.\n\nages &lt;- c(23, 54, 8)\nnames(ages) &lt;- c(\"michaela\", \"jane\", \"jacques\")\nages\n\n\n\nMissing Values\nLast but not least. Sometimes, we have missing values in our data. In R, missing values are denoted by NA. This is not treated as a character string but as a special symbol.\nYou can insert a placeholder for a missing value into a numeric or character vector by simply typing NA in the list of elements.\n\na&lt;-c(1,5,7,NA,11,14)\na\n\n\nb &lt;- c('michaela', 'bill', NA, 'jane')\nb\n\n\n\n\nDataframes\nData frames are probably the most important data structure in R. They are the default form for representing data sets for statistical analyses.\nData frames have a certain number of columns, and each column has the same number of rows. Each column is a vector, and so data frames are essentially collections of equal-length vectors. (This is also why we spent so much time on vectors above…)\nThere are two ways of creating data frames. We can create a data frame in R by importing a data file, usually in .csv or .xlsx format. (We will discuss how to import files next week.)\nOr we can use the data.frame() function to create a data frame from scratch, as in the following example.\n\ndata_df &lt;- data.frame(name = c('bill', 'jane', 'jacques'), age = c(23, 54, 8))\n\ndata_df\n\nAs you can see, we have now created a data frame with two columns (name, age) and three rows (displaying the name and age of each person, Bill, Jane and Jacques). The columns are our variables and the rows are our observations of these variables.\nWe can refer to specific elements of the data frame by using indices. In the example below, there are two elements within the index [ ], one for the rows, one for the columns. These are separated by a comma [ , ].\nFor example, to refer to the element that is in the second row, first column, you would type the following.\n\ndata_df[2 ,1]\n\nYou can also retrieve multiple elements. One way of doing this is by leaving one of the indices blank.\nIf you leave the first index blank (e.g., [ , 1]), then you are telling R that you want the information from all the rows. In the example below, you retrieve the information that is in all the rows that are in column 1.\n\ndata_df[ ,1]\n\nIn contrast, if you leave the second index blank ([2, ], you will retrieve the information found in the second row across the two columns.\n\ndata_df[2 , ]\n\nWe can also be more specific. For example, you can refer to the first and third row of the second column, we would type:\n\ndata_df[c(1, 3), 2]\n\nOn the other hand, we can also refer to a column by name. To do this, we need to use the $ notation.\n\ndata_df$name\n\ndata_df$age\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nDid you notice that RStudio will automatically suggest the variable names after you typed the $? The code completion feature in RStudio makes writing and executing code much easier!\nIt will do this for pretty much everything that is either a function, a variable, or even an argument (we come to those later), provided that you have typed at least three characters (or press Tab to get there faster)"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-8-functions",
    "href": "Worksheets/Worksheet_wk1.html#step-8-functions",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 8: Functions",
    "text": "Step 8: Functions\nWhile data structures hold data in R, functions are used to do things with the data. You have already encountered a few functions above, namely sqrt(), c(), and data.frame().\nAcross all R packages and R’s standard library, there are tens of thousands of functions available for you to use. However, most of our analyses in this course will require only a relatively small number of functions.\nBelow is a general introduction to functions; we will cover functions in more detail as we progress through this course.\nFunctions tend to have the following structure:\nfunction(argument 1, argument 2, argument 3, ...)\nWe can think of functions as actions and arguments as the inputs, i.e. something the functions act on. Most functions require at least one argument. If they have more than one argument, these are separated by commas as in the example above.\nFor example, see what happens when you type the following two commands.\n\nsqrt()\nsqrt(4)\n\nThe function sqrt() requires an argument; if you fail to supply an argument you will get an error message (Error in sqrt()…)\nHere are another few functions that are helpful for our analyses.\nWe can count the number of elements in a given vector by using the length() function.\n\nlength(new_numbers)\n\nWe can calculate sum, mean, median, and standard deviation as follows. (More on this in future sessions when we discuss exploratory data analysis.)\n\nsum(new_numbers)\n\nmean(new_numbers)\n\nmedian(new_numbers)\n\nsd(new_numbers)\n\nYou can also nest functions inside each other, such as:\n\nround(sqrt(mean(new_numbers)))\n\nHere, we use three functions, each nested within the other. In the example, we first calculated the mean of the vector new_numbers (460.381), then the square root of this value and finally rounded it. We could have done the same calculation in three steps, as in the example below, but nesting the functions in a single command allows us to be more efficient.\nNow, I don’t like nesting functions and neither should you. Next session I will cover this more clearly, and introduce you to a set of functions and stylistic choices that are the gold standard in psychology and have a huge user base (meaning there’s plenty of help out there). For now, just be in awe of the complexity of carrying out multiple functions in R.\n\nOptional arguments\nIn some cases, functions can also take an additional argument. A good example is the mean() function, which can an additional argument called trim. If we add the trim argument to the mean function, the command will first remove a certain proportion of the extreme values of the vector and then calculate the mean. This is very useful when we are dealing with outliers in our data, for example. (We will talk more about outliers in future sessions.)\nIn order to trim observations, we need to specify a value between 0 to 0.5. This will trim the highest and the lowest values before calculating the mean. Naturally, a trim value of 0 means you’re not trimming anything, so the value assigned to trim should be greater than 0. For example, a value of 0.1 means you’re trimming the 10% highest and lowest observations, 0.2 means you’re trimming the 20% highest and lowest, and so forth.\n\nmean(new_numbers)\n\nmean(new_numbers, trim=0.0)\n\nmean(new_numbers, trim=0.1)\n\nmean(new_numbers, trim=0.2)\n\nmean(new_numbers, trim=0.3)\n\nmean(new_numbers, trim=0.4)\n\nmean(new_numbers, trim=0.5)"
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#step-9-help-pages",
    "href": "Worksheets/Worksheet_wk1.html#step-9-help-pages",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Step 9: Help Pages",
    "text": "Step 9: Help Pages\nRStudio has very helpful pages for the available functions. This is useful when you’re not sure if a function requires an argument, or if you’re in doubt about the use of arguments such as trim.\nYou can access the help page for a given function in different ways.\nThe most efficient one is by typing a question mark and the function name in the command line. If you now press Return (Mac) / Enter (Windows), this command will also open the help page for the function. Alternatively, you can use thehelp()function in the command line, as below.\n\n?mean()\n\nhelp('mean')\n\nThen there is my preferred option (and again, when we start using the script pane, I will make this clear):\nYou can also go to the search line of the Help tab in the Files, Plots, Packages, Help pane (bottom right of the screen) and type the name of the function there (mean). There is a useful shortcut to search R Help, namely Ctrl+Option+F1 (Mac) and Ctrl+Alt+F1 (Windows).\nIn each of the cases above, RStudio will open the help page for the function in question in the Help tab."
  },
  {
    "objectID": "Worksheets/Worksheet_wk1.html#take-home-task",
    "href": "Worksheets/Worksheet_wk1.html#take-home-task",
    "title": "1. Introduction to quantitative research methods using R",
    "section": "Take home task",
    "text": "Take home task\nThe following table displays the scores of students in two foreign language exams, one administered at the beginning of term, the other at the end of term.\nCreate a data frame called language_exams with the information provided in the table, then answer the questions below using R. To save you the headache of tediously typing it all out, you can highlight and paste the code below as-is into your own script.\n\nlanguage_exams &lt;- data.frame(\n  student_id = c('Elin', 'Spencer', 'Crystal', 'Arun', 'Lina', 'Maximilian', 'Leyton', 'Alexandra', 'Valentina', 'Lola', 'Garfield', 'Lucy', 'Shania', 'Arnold', 'Julie', 'Michaela', 'Nicholas'), \n  exam_1 = c(93, 89, 75, 52, 34, 50, 46, 62, 84, 68, 74, 51, 84, 34, 57, 25, 72), \n  exam_2 = c(98, 96, 94, 65, 50, 68, 58, 77, 95, 86, 89, 70, 90, 50, 67, 37, 90))\n\n\nWhat are the mean scores for exam 1 and exam 2?\n\n\nWhat is the difference between the two means?\n\n\nWhat are the mean scores for the two exams if you remove extreme values (the top and bottom 20%) from each?\n\n\nBased on the previous step (with outliers removed): What is the difference between the two means now? Please round the value before reporting the result.\n\n\nCan you do steps 3 and 4 in a single command?"
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html",
    "href": "Worksheets/Worksheet_wk2.html",
    "title": "2. Data management and data wrangling",
    "section": "",
    "text": "Three important things to remember:"
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-0-installing-tidyverse",
    "href": "Worksheets/Worksheet_wk2.html#step-0-installing-tidyverse",
    "title": "2. Data management and data wrangling",
    "section": "Step 0: Installing tidyverse",
    "text": "Step 0: Installing tidyverse\nI mentioned tidyverse in the lecture, and now we will intall and load it, before using it (mainly for pipes!)\nAs a one-off (on a per machine basis) the first command only needs to be run when we first want a package. As noted before, there are thousands of functions available to R, having them all pre-packaged would break your computer and you don’t need every single one.\n\ninstall.packages(\"tidyverse\")\n\nThere is little to know about this at this stage, as the function does a lot of the legwork for us. It looks on the CRAN (The Comprehensive R Archive Network) which contains the R approved packages. It downloads it so you can use all the functions contained in a spacific package.\nAs stated before, tidyverse is a collection of packages, and we will need to understand that later on, but for now: no need.\nNow to load the package so we can use the functions:\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.4     ✔ purrr   1.0.2\n✔ tibble  3.2.1     ✔ dplyr   1.1.2\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.3     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\n\nAs above, you will get a bunch of messages in the console, we can reasonably ignore these for now.\n\n\n\n\n\n\nNote\n\n\n\nAs a general point, we would run install.packages() in the console, and place library() at the top of a script. The next section should make this a bit clearer as to the difference"
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-1-scripts",
    "href": "Worksheets/Worksheet_wk2.html#step-1-scripts",
    "title": "2. Data management and data wrangling",
    "section": "Step 1: Scripts",
    "text": "Step 1: Scripts\nA script is essentially a sequence of commands that we want R to execute. As Winter (2019) points out, we can think of our R script as the recipe and the R console as the kitchen that cooks according to this recipe. Let’s try out the script editor and write our first script. Typing commands in the console is good for one off commands (maybe to check the class() or to install.packages()), but the script is better for keeping the steps in order.\nWhen working in R, try to work as much as possible in the script. This will be a summary of all of your analyses, which can then be shared with other researchers, together with your data. This way, others can reproduce your analyses.\nThus far, you have typed your command lines in the console. This was useful to illustrate the functioning of our R, but in most of your analyses you won’t type much in the console. Instead, we will use the script editor.\nThe script editor is the pane on the top left of your window. If you don’t see it, you need to open a new script first. For this, press Cmd+Shift+N (Mac) or Ctrl+Shift+N (Windows). Alternatively, in the menu, click File &gt; New File &gt; RScript.)\nIn the script editor (not the console), type the following command in line 1 press Return (Mac) / Enter (Windows).\n\n2 + 3\n\nAs you can see, nothing happened. There is no output in the Console pane; the cursor just moved to the next line in the script editor (line 2). This is because you did not execute the script.\nTo execute a command in the script editor, you need to place your cursor anywhere on the line you wish to execute and then click the Run icon in the Script editor pane. If you do this, then the following output will appear in your Console.\nYou can also run the current command line or selection in the script by pressing Cmd+Return (Mac) or Ctrl+Enter (Windows). This will also send your command from the script editor to the console. (I suggest using the shortcut, it’s much more efficient.)\nIn the script, you can have as many lines of code as you wish. For example, you can add the following three commands to your script.\n\nscores &lt;- c(145, 234, 653, 876, 456) \n\nmean(scores)\n\nsd(scores)\n\nTo execute each one separately, just go to the line in question and click the Run icon or, even better, press the keyboard shortcut.\nYou can also run multiple commands in one go. For this, you either highlight several lines and then press the Run icon (or keyboard shortcut). Try it with the above three lines.\nTo execute all commands in the script, you click the Source icon (next to the Run icon) in the Script editor pane. Or just use the shortcut Cmd+Option+R (Mac) or Ctrl+Alt+R (Windows).\n\nMultiline commands\nUsing the script editor is particularly useful when we write long and complex commands. The example below illustrates this nicely.\nThis is a fairly long command, written in the console in one line.\n\ndf &lt;- data.frame(name = c('jane', 'michaela', 'laurel', 'jaques'), age = c(23, 25, 46, 19), occupation = c('doctor', 'director', 'student', 'spy'))\n\nbut in a multiline format:\n\ndf &lt;- data.frame(name = c('jane', 'michaela', 'laurel', 'jaques'), \n                 age = c(23, 25, 46, 19), \n                 occupation = c('doctor', 'director', 'student', 'spy'))\n\nNote the indentations, this is done automatically by RStudio as it recognises what is grouped according to parentheses.\n\n\nComments\nAn important feature of R (and other programming languages) is the option to write comments in the code files. Comments are notes, written around the code, that are ignored when the script is executed. In R, anything followed by the # symbol on any line is treated as a comment. This means that a line starting with # is ignored when the code is being run. And if we place a # at any point in a line, anything after the hash tag is also ignored. The following code illustrates this.\nComments are really useful for writing explanatory notes to ourselves or others.\n\n# Here is data frame with three variables.\n# The variables refer to the names, ages, and occupations of the participants.\ndf &lt;- data.frame(name = c('jane', 'michaela', 'laurel', 'jaques'), \n                 age = c(23, 25, 46, 19),\n                 occupation = c('doctor', 'director', 'student', 'spy'))\n\nor\n\n2 + 3 #This is addition in R.\n\n\n\nCode sections\nTo make your script even clearer, you can use code sections. These divide up your script into sections as in the example below. To create a code section, go the line in the script editor where you would like to create the new section, then press Cmd+Shift+R (Mac) or Ctrl+Shift+R (Windows). Alternatively, in the Menu, select Code &gt; Insert Section.\nThe lines with the many hypens create the sections\n\n# Create vectors ---------------------------------------------------\n\nscores_test1 &lt;- c(1, 5, 6, 8, 10) # These are the scores on the pre-test.\nscores_test2 &lt;- c(25, 23, 52, 63) # These are the scores on the post-test.\n\n# A few calculations -----------------------------------------------\n\nmean_test1 &lt;- mean(scores_test1)\nmean_test2 &lt;- mean(scores_test2)\n\nround(mean_test1 - mean_test2) # The difference between pre and post-tests.\n\nOnce you have created a section, you can ask R to run only the code in a specific region. This is because R recognizes script sections as distinct regions of code.\nTo run the code in a specific section, first go to the section in question (e.g., the section called # A few calculations ————) and then either press Cmd+Option+T (Mac) or Ctrl+Alt+T (Windows). You can also use the menu, Code &gt; Run Region &gt; Run Section. Have a go to see if this works out well.\n\n\nSaving scripts\nFinally, you can also save your script. To do this, just click the Save icon in the Script editor pane or press Cmd+S (Mac) or Ctrl+S (Windows). The script can be named anything, but it is often recommended to use lowercase letters, numbers and underscores only. (That is, no spaces, hyphens, dots, etc.)\nThe script is saved in the .R format in your directory. If you later double click it, the file will open in RStudio by default, but you can also view and edit the file in Word and similar programs."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-2-a-bit-more-on-packages",
    "href": "Worksheets/Worksheet_wk2.html#step-2-a-bit-more-on-packages",
    "title": "2. Data management and data wrangling",
    "section": "Step 2: A bit more on packages",
    "text": "Step 2: A bit more on packages\nIt’s important to acknowledge the important work done by the developers who make R packages available for free and open source. When you use a package for your analyses (e.g., tidyverse or lme4), you should acknowledge their work by citing them in your output (dissertation, presentation, articles, etc.). You can find the reference for each package via the citation() function, as in the examples below.\n\ncitation(\"tidyverse\")\n\ncitation(\"lme4\")\n\nYou can also install packages by using the Packages tab in the Files, Plots, Packages, etc. pane. As you see in the figure below, the base package is already installed. You can install more packages by scrolling through the list (or using the search option to narrow down the choices) and then selecting the tick box to the left of the package. If you do this, you will see that the click will run the install.packages() command in the console.\nAs I mentioned above, run install.packages() in the console as a one-off command, you do not need to run this every time you want to use a package. Everytime we want to use a package in a given session, we need to tell R to load it up, which is why we put library() at the top of the script, so we can use the functions."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-3-working-directories-and-clean-workspaces",
    "href": "Worksheets/Worksheet_wk2.html#step-3-working-directories-and-clean-workspaces",
    "title": "2. Data management and data wrangling",
    "section": "Step 3: Working directories and clean workspaces",
    "text": "Step 3: Working directories and clean workspaces\nEvery R session has a working directory. This is essentially the directory or folder from which files are read and to which files are written.\nYou can find out your working directory by typing the following command. Your output will obviously look different from the one below, which refers to my machine\n\ngetwd()\n\n[1] \"/Users/ivorym/Documents/PhD/Teaching/23_24/FASS512/Worksheets\"\n\n\nYou can also use a command to list the content in the working directory. (Alternatively, you can see your direct by using the Files tab in the Files, Packages, Plot, etc. pane.)\n\nlist.files()\n\nI suggest you create a new working directory on your computer desktop and then use it for the entire course. Important files related to your R tasks (scripts, data, etc.) should later be downloaded to this folder.\nThe first step is for you to create a folder called FASS512 (or similar) in a sensible place on your computer. You can do this by going to the Files tab (in the Files, Packages, etc. pane) and clicking the “Create a new folder” icon. Place each weekly set of weekly files in their own weekly folders.\nOnce you have created the “statistics” folder on the desktop, go to the menu to set the default working directory to the new “statistics” folder. The easiest way is to go to the menu, RStudio &gt; Preferences. This should call up the following window.\nIn the window, click the Browse button and set the default working directory to the “statistics” folder in the desktop."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-4-loading-data",
    "href": "Worksheets/Worksheet_wk2.html#step-4-loading-data",
    "title": "2. Data management and data wrangling",
    "section": "Step 4: Loading data",
    "text": "Step 4: Loading data\nWhen we are dealing with data in our analyses, we usually begin by importing a data file. R allows you to important data files in many different formats, but the most likely ones are .csv and .xlsx.\nI have uploaded several data files to our Moodle page. Please go to folder called “Data sets to download for this session” in the section for today’s session, then download the files in the folder and place them in your working directory (the statistics folder you just created). The files are from Winter (2019) and Fogarty (2019).\nLet’s try out loading data files. In the examples below, you will import three types of files: .csv, .txt, and .xlsx. Remember: You need to download the data files from our Moodle page and place them in our working directory first. Otherwise, you cannot import the files from our directory into R.\n\nCSV\nWe can use the read_csv() function from dplyr (part of the tidyverse) to load data that is in .csv format. The command below will load the data set (‘nettle_1999_climate.csv’) and create a new label for this data set (languages). There exists a read.csv() function in base, but it is slower and not as ‘smart’ as read_csv().\n\nlanguages &lt;- read.csv('nettle_1999_climate.csv')\n\nAlternatively, you can load data files by clicking File &gt; Import Dataset &gt; From Text (readr). In the dialogue window, then click browse and select the file nettle_1999_climate.csv. You can change the name of the data set in the text box at the bottom left, below Import Options, where it says Name.\n\n\n\n\n\n\nNote\n\n\n\nI am giving you these alternative GUI-based methods for carrying out the same steps as what is written in the script. I offer these to highlight how things can be done in many ways, but preferably you will use the script for pretty much everything. This creates a record of the commands needed to reproduce your analysis, which is better for future researchers (which includes you in a week’s time)\n\n\n\n\nTXT\nThe data file you just imported is in the .csv format. You can important data from files in other formats, too. If the data is in .txt format, you can simply use the following command.\n\ntext_file &lt;- read_table('example_file.txt', sep = \"\\t\", header = TRUE) #(Note: Ignore the warning message in the console.)\n\nThe command creates a new data set called text_file. The read_table() function requires you to specify a separator (the argument sep). A separator is whatever divides your columns in your table. If your data is tab-delimited, then you include sep = ‘ in your command, as above. If you are using commas, then you need to include sep =’,’ and so forth. The header = TRUE argument indicates that your data set has a head (usually the column names).\n\n\nxlsx\nIf the data is an Excel spreadsheet (e.g., .xlsx format), you can proceed as follows. Ideally it shouldn’t be, as csv are a universal file format that can be read across many machines. As a general rule, it is important to use these universal filetypes (csv, txt, pdf, html…) for better reproducibility and data management (Towse et al., 2021)1\n\nlibrary(readxl) #you may need to run install.packages(\"readxl\") first\n\nspreadsheet_exl &lt;- read_excel('simd.xlsx', sheet = 'simd')\n\nFirst, you need to install the readxl package. Then, you create a new data set called spreadsheet_exl by using the read_excel() function.\nNote: Since spreadsheets have multiple sheets, you need to specify the name of the sheet you would like to import by using the sheet argument. In our case, the sheet is called simd, hence sheet = ‘simd’.\nRStudio can handle many other file extensions to import datasets. You can find out information on how to import other file types by using the R help function (or by searching on Google)."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-5-examining-datasets",
    "href": "Worksheets/Worksheet_wk2.html#step-5-examining-datasets",
    "title": "2. Data management and data wrangling",
    "section": "Step 5: Examining datasets",
    "text": "Step 5: Examining datasets\nIf you have followed the steps above, you will have imported three data sets, languages, spreadsheet_exl, and text_file. You can now start exploring the data. We will focus on languages as an example.\nEvery time you import data, it’s good to check the content, just to make sure you imported the correct file.\nThe easiest way to do this is by using the View() function. This allows you to inspect the data set in the script editor. Note: The function requires a capital V. If you have tidyverse loaded, which we do, then there is a view() function as well. These are functionally equivalent. Use whichever, but View() will always work\nIf you run the command below, you will see that this shows the data (a table) in a tab of the script editor. It will also be displayed in the console.\n\n\n\n\n\n\nNote\n\n\n\nRemember what I have said previously about some content being better off in the console rather than the script? This is another example of what to put in the console instead (like class() or install.packages().\nWhy? Great question, because it’s a one-off command that we don’t need in our script. It’s a sanity check, like class(), and it doesn’t add anything of value to the script. The script should be the minimum series of commands that are required to go from one stage to another. Taking a visual look at a dataframe is superfluous to the actual analysis\n\n\n\nView(spreadsheet_exl) \nView(languages)\n\nYou can also inspect your data by visiting the Environment tab in the Environment, History, Connections, etc. pane. As you can see in the figure below, this will tell you thatlanguageshas 74 observations (rows) and five variables (columns).\nIf you would like to examine variables, you can start by using the str() function (str for structure), as in the example below.\n\nstr(languages)\n\nAs you can see above, the str() function will tell you many useful things about your dataset. For example, it will reveal the number of observations (rows, 74) and variables (columns, 5), and then list the variables (Country, Population, Area, MGS, Langs). For each variable, it will also indicate the variable type (chr = character strings, num = numeric, intd = integer). The str() function will also display the first observations of each variable (Algeria, Angola, Australia, Bangladesh, etc.).\nYou can also check the names of variables separately by using the names() function, or check the variable type by checking the class() function, but it’s easier to just use the str() function as in the example above.\nIf you prefer, you can restrict your inspection of to the first or final rows of the data set. You can do this by using the head() and tail() function. This is helpful if your tables has lots of rows. It complements str() as it shows you a sample of the actual data, not just the structure.\n\nhead(languages) #default is six rows to display\ntail(languages, n = 5) #show last five rows\n\nHow could you show the first 10 rows?\nThere is also a very helpful function called summary(). As you can see in the example below, this function will provide you with summary information for each of your variables.\nFor numeric/integer variables such as Populations, Area, MGS, and Langs, this command will calculate the minimum and maximum values, quartiles, median and mean. (We will discuss summary statistics in more detail later.)\nFor character variables, as in Country, the command will simply provide you with the number of observations (length) for this variable.\n\nsummary(languages)\n\nIn large datasets, you might want to examine only a specific variable. You can do this by using the $ as an index. For example, if you would just like to examine the variable Population in the languages dataset, you could proceed as follows.\n\nstr(languages)\n\nstr(languages$Population)\n\nclass(languages$Population)\n\nhead(languages$Population)\n\ntail(languages$Population)\n\nsummary(languages$Population)\n\nWhich of the above six commands are best placed in the script or console?\n\n\n\n\n\n\nNote\n\n\n\n\n\nUltimately, there is no right or wrong answer. Personally,\nstr() belongs in the console because it should just be a quick check that it is the expected shape. It could go in the script if it was part of a more formal test. A sanity check is something that makes you go “oh, I should just make sure”, whereas a test is more in line with thoughts of “if it isn’t have an identical shape to dataframe2, none of this works” - a nuanced difference that we may perhaps explore in later sessions.\nclass() goes in the console - it is very much a sanity check. If it transpires the class isn’t what you wanted, we can coerce them into different classes, which we would include as a step in the script, but we don’t need to run the check everytime in the script if we are just going to coerce it anyway…\nhead() and tails() depends. If you’re just having a little look, then console. If it is something you are then using in the analysis, the script. Most likely the console though. If you can exit RStudio and reopen the script and it runs without errors, then it’s fine to leave in the console. If it fails, maybe you need things in the script?\nsummary() is one I usually keep in the script - particularly if I am reporting the summary of statistics (see a later session) because it is meaningful content that I need."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#step-6-closing-your-r-session",
    "href": "Worksheets/Worksheet_wk2.html#step-6-closing-your-r-session",
    "title": "2. Data management and data wrangling",
    "section": "Step 6: Closing your R session",
    "text": "Step 6: Closing your R session\nThe last step is to close your R session. When you quit RStudio, a prompt will ask whether you want to save the content of your workspace. It is better to NOT save the workspace. When you start RStudio again, you will have a clean workspace. You then just re-run your scripts.\nIf you have written your scripts well, upon re-open, you should be able to produce the exact same steps without error and without odd additional windows opening (because we put View() in a script…).\nSo, I would save R scripts (especially if these are very long and are relevant to your analyses), but I would not the workspace contents."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#take-home-task",
    "href": "Worksheets/Worksheet_wk2.html#take-home-task",
    "title": "2. Data management and data wrangling",
    "section": "Take home task",
    "text": "Take home task\nTo complete this homework task, you will need to download the language_exams data file from our Moodle page into your working directory.\nIn the file, you will find the (fictional) scores and ages of 475 students who took an intermediate Portuguese language course at university. Students were tested three times: first in September to check their Portuguese proficiency at the beginning of the course, then again in January as part of their mid-term examination, and finally in June as part of their final examination. On each occasion, students had to complete three subtests to respectively assess their Portuguese vocabulary, grammar and pronunciation. The scores for exams 1, 2 and 3 are composite scores, i.e. each combines the results of the three subtests.\nYour task is to run a basic analysis of the exam data using an R script.\nIn your script, please include all the steps, including the command that loaded the data.\nPlease also include sections to make your script very clear, as well as comments.\n\nHow many observations and columns does the datafile contain?\n\n\nRun commands to display the first and the last five lines of the table.\n\n\nWhat is the average age of participants? Report this as a whole number\n\n\nWhat type of variable is student_id?\n\n\nWhat is the rounded mean score on exam 3 to 2 decimal places?\n\n\n\n\n\n\n\nTip\n\n\n\n\n\nNot sure how? Type ?round() into the console and read the help page. Specifically look under the Arguments section and the examples (the second to last is the best one)\n\n\n\n\nWhat is the difference between the mean scores on exams1 and 2?\n\nPlease save the script to discuss at the next session."
  },
  {
    "objectID": "Worksheets/Worksheet_wk2.html#footnotes",
    "href": "Worksheets/Worksheet_wk2.html#footnotes",
    "title": "2. Data management and data wrangling",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTowse, A. S., Ellis, D. A., & Towse, J. (2021). Making data meaningful: Guidelines for good quality open data. The Journal of Social Psychology, 161(4), 395–402. https://doi.org/10.1080/00224545.2021.1938811↩︎"
  }
]